<!-- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
    SPDX-License-Identifier: MIT-0 -->
<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css"
    integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1"
    crossorigin="anonymous">
<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.3.0/font/bootstrap-icons.css"
    integrity="sha384-YdM/o2MTG+kIKs1sV/gSEWXZo5d1DdBeuo/6s8qMJd5I5FKkStdHSXeNukljrWUZ"
    crossorigin="anonymous">

<script src="https://assets.crowd.aws/crowd-html-elements.js"></script>
<script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW"
    crossorigin="anonymous"
></script>

<script
    src="https://cdn.jsdelivr.net/npm/amazon-textract-response-parser@0.3.1"
    integrity="sha384-DQFpMcZfgat/UD7WciA+9nACuyogtaMy6c0h/t+2EqxaSwkBt130PdDYh2/cYPQe"
    crossorigin="anonymous"
></script>

<crowd-form>
    <!-- Need to update post-processing Lambda if change this 'boxtool' name (or other names) -->
    <crowd-bounding-box
        id="annotator"
        name="boxtool"
        src="{{ task.input['source-ref'] | grant_read_access }}"
        header="AUTO-GENERATED BY NOTEBOOK"
        labels="AUTO-GENERATED BY NOTEBOOK"
    >
        <short-instructions>
            <p>
                Use the tools on the right to draw bounding boxes around the values for each field type that's included
                on the page. Then, review and correct the OCR extractions for each one on the left before clicking
                Submit.
            </p>
            <p>
                Please read the 'annotation guidelines' in the "More Instructions" link below for more detailed
                guidance.
            </p>
            <div
                id="ocr-status"
                class="alert alert-info ocr-status"
                src="{{ task.input['textract-ref'] | grant_read_access }}"
                page="{{ task.input['page-num'] }}"
            >
                <i class="bi bi-arrow-clockwise status-alert-icon" aria-hidden="true"></i>
                <span class="status-alert-header">Please wait...</span>
                <div class="status-alert-body">
                    Loading OCR result. If this takes more than a few seconds, please try exiting and re-entering the
                    task or contact the task administrator.
                </div>
            </div>

            <hr/>

            <h4>OCR Results</h4>
            <div id="ocr-fields">
                <!-- Dynamic control groups will be inserted into this region -->
            </div>
        </short-instructions>

        <full-instructions>
            <p>Thank you for your help on our annotation task!</p>

            <h3>Contents</h3>
            <ol>
                <li>Using the tool</li>
                <li>Annotation guidelines</li>
            </ol>

            <h3>Using the tool</h3>
            <p>
                You will be presented with an image (centre), a set of available field labels (right), and an OCR
                results pane (left).
            </p>
            <p>
                Select a target field type (such as email, address, etc) on the right, then draw bounding boxes over
                the image to indicate where the data is visible in the page.
            </p>
            <p>
                To highlight non-rectangular regions, draw multiple, overlapping bounding boxes of the same label
                class. These will be consolidated into one field automatically in the OCR results pane.
            </p>
            <p>
                (If the tool has loaded correctly) a new item will appear in the OCR results pane for each region you
                annotate on the image - including the OCR extracted words at that location, and radio buttons for you
                to indicate whether the transcription was:
            </p>
            <ul>
                <li>"Correct"</li>
                <li>"Wrong" (and you're able to confidently provide a correct transcription), or</li>
                <li>
                    "Unclear" (you're not able to clearly read what the result should be - due to poor handwriting or
                    similar)
                </li>
            </ul>
            <p>
                If you select "Wrong", you'll also be prompted to enter the correct transcription for that section.
                When you've annotated all fields for the page and reviewed all OCR results, go ahead and click "Submit"
                (bottom right) to move on to the next task.
            </p>
            <p>
                Although the framework for this tool is a stable service, the specific OCR workflow here is a custom
                prototype and therefore may still have some bugs. If you encounter problems with, for example, the task
                not loading correctly or the tool not working as described, please try:
            </p>
            <ul>
                <li>Refreshing the page</li>
                <li>Exiting/returning the task (not submitting) and then "start working" from the task list again</li>
            </ul>
            
            <!-- Per-field annotations guidelines to be appended: AUTO-GENERATED BY NOTEBOOK -->
        </full-instructions>
    </crowd-bounding-box>
    <crowd-toast id="ocr-required-fields-error" duration="5000">
        <crowd-alert type="error">
            Please fill out required fields in the 'OCR Results' section (in the 'Instructions' pane on the left).
        </crowd-alert>
    </crowd-toast>
</crowd-form>

<style>
    @-moz-keyframes spin { 100% { -moz-transform: rotate(360deg); } }
    @-webkit-keyframes spin { 100% { -webkit-transform: rotate(360deg); } }
    @keyframes spin { 100% { -webkit-transform: rotate(360deg); transform:rotate(360deg); } }

    .ocr-status .status-alert-icon {
        font-size: 1.2rem;
        position: absolute;
    }

    .ocr-status .status-alert-header {
        padding-left: 1.5rem;
        font-weight: bold;
    }
    .ocr-status .status-alert-body {
        padding-top: 0.5rem;
    }

    .ocr-status .bi-arrow-clockwise {
        -webkit-animation: spin 4s linear infinite;
        -moz-animation: spin 4s linear infinite;
        animation: spin 4s linear infinite;
    }

    .field-container {
        border-style: solid;
        border-width: 3px;
        border-color: #bbb;
        padding: 0.5rem;
        margin-bottom: 15px;
    }

    .ocr-output {
        border: 1px solid #333;
        background-color: #eee;
        font-family: 'Courier New', Courier, monospace;
        padding: 0.5rem 0.2rem;
    }
</style>

<script>
    window.ocrFields = [];
    var ocrResult;
    var pageNum = 1;

    document.addEventListener("all-crowd-elements-ready", function(event) {
        updateOcrStatus("loading");

        var pageNumFromManifest = parseInt(document.querySelector(".ocr-status").getAttribute("page"));
        if (isFinite(pageNumFromManifest)) {
            pageNum = pageNumFromManifest;
        } else {
            console.warn(
                "Task input did not include valid page number, defaulting to 1 (assuming single-page document)"
            );
        }

        // Intercept submit clicks and display error message if the OCR review fields are not filled in:
        window.annotator.shadowRoot.querySelector("awsui-button[data-testid=crowd-submit]").addEventListener(
            "click",
            function(evt) {
                console.log("Checking required OCR Fields");
                if (areRequiredOCRFieldsMissing()) {
                    try {
                        document.getElementById("ocr-required-fields-error").open();
                    } catch (err) {
                        console.warn("Failed to open error toast - defaulting to alert", err);
                        alert(
                            "Please fill out required fields in the 'OCR Results' section (in the instructions pane)"
                        );
                    }
                    evt.stopPropagation();
                    evt.preventDefault();
                }
            },
            true,
        );

        // Update our OCR component's model of the annotations whenever something changes
        // (Could consider trying to find a less noisy/often event, but mouseup works OK)
        annotator.addEventListener("mouseup", function() {
            setTimeout(
                function() { onImageAnnotationUpdate(); },
                200
            );
        });

        try {
            var ocrJsonUrl = document.getElementById("ocr-status").attributes.src.value;
            fetch(ocrJsonUrl)
                .then(function(response) { return response.json(); })
                .then(function(data) {
                    console.log(data);
                    ocrResult = new trp.TextractDocument(data);
                    console.log(ocrResult);
                    var expectedPageCount = isFinite(pageNumFromManifest) ? pageNumFromManifest : 1
                    if (ocrResult.nPages != expectedPageCount) {
                        console.warn(
                            [
                                "OCR result has unexpected page count",
                                ocrResult.nPages,
                                "!=",
                                expectedPageCount,
                            ].join(" ")
                        );
                    }
                    updateOcrStatus(null);
                })
                .catch(function(err) {
                    console.error(err);
                    updateOcrStatus("error");
                });
        } catch (err) {
            console.error(err);
            updateOcrStatus("error");
        }
    });

    function areRequiredOCRFieldsMissing() {
        var missingFields = false;
        for (var container of document.getElementById("ocr-fields").children) {
            for (var reqdField of container.querySelectorAll("[required]")) {
                var fieldVal = reqdField.value;
                if (!fieldVal) {
                    console.warn("Missing required field: ", reqdField);
                    missingFields = true;
                    break;
                }
            }
            if (missingFields) break;
            for (var radioGroup of container.querySelectorAll("crowd-radio-group")) {
                var radiosSelected = 0;
                for (var radioButton of radioGroup.querySelectorAll("crowd-radio-button")) {
                    if (radioButton.checked) ++radiosSelected;
                }
                if (radiosSelected === 0) {
                    console.warn("Missing required radios:", radioGroup)
                    missingFields = true;
                    break;
                } else if (radiosSelected > 1) {
                    console.warn("Detected multiple radios set in group:", radioGroup);
                }
            }
            if (missingFields) break;
        }
        return missingFields;
    }

    function updateOcrStatus(status) {
        var el = document.getElementById("ocr-status");
        if (!status) {
            el.style.display = "none";
        } else if (status == "loading") {
            el.classList.remove("alert-danger");
            el.classList.add("alert-info");
            var icon = el.querySelector(".status-alert-icon");
            icon.classList.remove("bi-exclamation-octagon");
            icon.classList.add("bi-arrow-clockwise");
            el.querySelector(".status-alert-header").innerText = "Please wait...";
            el.querySelector(".status-alert-body").innerText =
                "Loading OCR result. If this takes more than a few seconds, please try exiting and re-entering the "
                + "task or contact the task administrator.";
            el.style.display = "";
        } else {
            el.classList.add("alert-danger");
            el.classList.remove("alert-info");
            var icon = el.querySelector(".status-alert-icon");
            icon.classList.add("bi-exclamation-octagon");
            icon.classList.remove("bi-arrow-clockwise");
            el.querySelector(".status-alert-header").innerText = "Error";
            el.querySelector(".status-alert-body").innerText =
                "OCR result failed to load. Please try refreshing the page, exiting and re-entering the task, or "
                + "contacting the task administrator.";
            el.style.display = "";
        }
    }

    function doIntervalsOverlap(aMin, aMax, bMin, bMax) {
        return (aMax >= bMin) && (bMax >= aMin);
    }

    function doBoxesOverlap(a, b) {
        return (
            doIntervalsOverlap(a.left, a.left + a.width, b.left, b.left + b.width)
            && doIntervalsOverlap(a.top, a.top + a.height, b.top, b.top + b.height)
        );
    }

    function consolidateBboxAnnotations(annotations) {
        var groups = []; // { label, boxes, boxIxs }
        annotations.forEach(function (box, ixBox) {
            var className = box.label;
            var matchedGroup = null;
            var newGroups = [];
            var prevClsGroups = groups.filter(function(g) { return (g.label == className); });
            groups.forEach(function (group) {
                if (
                    (group.label == className)
                    && group.boxes.some(function(groupBox) { return doBoxesOverlap(box, groupBox); })
                ) {
                    if (!matchedGroup) {
                        // This is the first group that's matched with the annotation
                        matchedGroup = group;
                        // TODO: Might be nice to check if any boxes are completely contained->redundant
                        matchedGroup.boxes.push(box);
                        matchedGroup.boxIxs.push(ixBox);
                        newGroups.push(matchedGroup);
                    } else {
                        // This box merges `group` into `matchedGroup`
                        matchedGroup.boxes = matchedGroup.boxes.concat(group.boxes);
                        matchedGroup.boxIxs = matchedGroup.boxIxs.concat(group.boxIxs);
                    }
                } else {
                    // This group does not overlap with this annotation or is different class - pass through
                    newGroups.push(group);
                }
            });
            if (!matchedGroup) {
                // This annotation does not overlap with any existing groups
                newGroups.push({
                    label: className,
                    boxes: [box],
                    boxIxs: [ixBox],
                });
            }
            groups = newGroups;
        });
        return groups;
    }

    function getWordsInBboxes(page, bboxes, bboxRefHeight=1.0, bboxRefWidth=1.0) {
        var matchingWords = [];
        // Normalize bboxes (since Textract geometries are already):
        bboxes = bboxes.map(function(box) {
            return {
                left: box.left / bboxRefWidth,
                top: box.top / bboxRefHeight,
                height: box.height / bboxRefHeight,
                width: box.width / bboxRefWidth,
            };
        });

        for (var line of page.iterLines()) {
            for (var word of line.iterWords()) {
                var wordArea = word.geometry.boundingBox.height * word.geometry.boundingBox.width;
                var isectAreas = bboxes.map(function(box) {
                    var isectLeft = Math.max(word.geometry.boundingBox.left, box.left);
                    var isectTop = Math.max(word.geometry.boundingBox.top, box.top);
                    var isectRight = Math.min(
                        word.geometry.boundingBox.left + word.geometry.boundingBox.width,
                        box.left + box.width,
                    );
                    var isectBottom = Math.min(
                        word.geometry.boundingBox.top + word.geometry.boundingBox.height,
                        box.top + box.height,
                    );
                    return (
                        Math.max(0, (isectRight - isectLeft))
                        * Math.max(0, (isectBottom - isectTop))
                    );
                });
                if (isectAreas.some(function(isect) { return (isect >= (wordArea / 2)); })) {
                    matchingWords.push(word);
                }
            }
        }
        return matchingWords;
    }
  
    function generateUid() {
        return [
            Date.now().toString(16),
            ("0000" + Math.floor(Math.random() * 10000)).slice(-4),
        ].join("-");
    }

    function onImageAnnotationUpdate() {
        var newAnnotations = annotator.value;
        var annotatorLabelsState = annotator.store.getState().label.labels;
        var labelColors = Object.keys(annotatorLabelsState).reduce(
            function(acc, nextKey) {
                acc[nextKey] = annotatorLabelsState[nextKey].color;
                return acc;
            },
            {}
        );
        console.log("label colors: ", labelColors);
        var imgHeight = newAnnotations.inputImageProperties.height;
        var imgWidth = newAnnotations.inputImageProperties.width;
        var newBoxes = newAnnotations.boundingBoxes;
        if (!ocrResult) {
            console.warn("Couldn't process image annotation update - OCR result not yet available");
            return;
        }

        // Consolidate bounding boxes to groups and extract OCR text:
        console.log("Consolidating:", newBoxes);
        var annGroups = consolidateBboxAnnotations(newBoxes);
        console.log(annGroups);
        annGroups.forEach(function(annGroup) {
            annGroup.labelId = annotator.labels.indexOf(annGroup.label);
            annGroup.words = getWordsInBboxes(
                ocrResult.pageNumber(pageNum),
                annGroup.boxes,
                bboxRefHeight=imgHeight,
                bboxRefWidth=imgWidth,
            );
            annGroup.ocrText = annGroup.words.map(function(w) { return w.text; }).join(" ");
        });

        // Map annotation groups to existing OCR fields:
        // TODO: Improve similarity matching!
        annGroups.forEach(function(annGroup, ixAnnGroup) {
            annGroup.ocrFieldIx = ixAnnGroup < window.ocrFields.length ? ixAnnGroup : null;
        });

        // Create new fields for unmatched annotation groups and update display for matched ones:
        var fieldsWithAnnotations = {};
        annGroups.forEach(function(annGroup, ixAnnGroup) {
            if (annGroup.ocrFieldIx == null) {
                // Create a new field for this unmatched annotation group:
                var ocrFieldId = generateUid();
                window.ocrFields.push({
                    id: ocrFieldId,
                    label: annGroup.label,
                    labelId: annGroup.labelId,
                    boxes: annGroup.boxes,
                    boxIxs: annGroup.boxIxs,
                    words: annGroup.words,
                    ocrText: annGroup.ocrText,
                });
                fieldsWithAnnotations[ocrFieldId] = true;
                var ocrFieldEl = renderOcrField(
                    ocrFieldId,
                    ocrText=annGroup.ocrText,
                    label=annGroup.label,
                    labelId=annGroup.labelId,
                    labelColor=labelColors[annGroup.label],
                    boxIxs=annGroup.boxIxs,
                );
                document.getElementById("ocr-fields").appendChild(ocrFieldEl);
            } else {
                // Update display of existing field for this annotation group:
                var ocrField = window.ocrFields[annGroup.ocrFieldIx];
                fieldsWithAnnotations[ocrField.id] = true;
                var container = document.getElementById("ocr-field-" + ocrField.id);
                var metaField = JSON.parse(
                    document.getElementById(["ocr", ocrField.id, "meta"].join("-")).getAttribute("value")
                );
                var metaChanged = false;
                // NOTE: We assume here LabelId only changes with Label, because why have 2 same-label classes?
                if (ocrField.label !== annGroup.label) {
                // Highly unlikely that the review still holds if the class changes!
                    container.querySelectorAll("crowd-radio-button").forEach(function(radio) {
                        radio.removeAttribute("checked");
                    });
                    ocrField.label = annGroup.label;
                    ocrField.labelId = annGroup.labelId;
                    metaField.label = annGroup.label;
                    metaField.labelId = annGroup.labelId;
                    metaChanged = true;
                }
                // TODO: Theoretically possible to move a box to different word of same content
                if (ocrField.ocrText !== annGroup.ocrText) {
                    container.querySelector(".ocr-output").innerText = annGroup.ocrText;
                    container.querySelectorAll("crowd-radio-button").forEach(function(radio) {
                        radio.removeAttribute("checked");
                    });
                    ocrField.ocrText = annGroup.ocrText;
                    metaField.ocrText = annGroup.ocrText;
                    metaChanged = true;
                }
                if (JSON.stringify(ocrField.boxIxs) !== JSON.stringify(annGroup.boxIxs)) {
                    metaField.boxIxs = annGroup.boxIxs;
                    metaChanged = true;
                }
                ocrField.boxes = annGroup.boxes;
                ocrField.boxIxs = annGroup.boxIxs;
                ocrField.words = annGroup.words;
                if (labelColors[annGroup.label]) {
                    container.style.borderColor = labelColors[annGroup.label];
                } else {
                    container.style.removeProperty("borderColor");
                }

                if (metaChanged) {
                    document.getElementById(["ocr", ocrField.id, "meta"].join("-")).setAttribute(
                        "value",
                        JSON.stringify(metaField),
                    );
                }
            }
        });

        // Clear out any old fields that don't have matching bbox annotations anymore:
        var newOcrFields = []
        ocrFields.forEach(function(ocrField, ixAnnGroup) {
            if (!fieldsWithAnnotations[ocrField.id]) {
                var container = document.getElementById("ocr-field-" + ocrField.id);
                container.parentElement.removeChild(container);
            } else {
                newOcrFields.push(ocrField);
            }
        });
        window.ocrFields = newOcrFields;
    }

    function renderOcrField(id, ocrText="", label=null, labelId=null, labelColor=null, boxIxs=[]) {
        var container = document.createElement("div");
        container.id = "ocr-field-" + id;
        container.classList.add("field-container");
        if (labelColor) container.style.borderColor = labelColor;

        var metastore = document.createElement("crowd-input");
        metastore.setAttribute("name", ["ocr", id, "meta"].join("-"));
        metastore.setAttribute("id", ["ocr", id, "meta"].join("-"));
        metastore.setAttribute(
            "value",
            JSON.stringify({
                label: label,
                labelId: labelId,
                boxIxs: boxIxs,
                ocrText: ocrText,
            }),
        );
        metastore.style.display = "none";
        container.appendChild(metastore);

        var ocrOutput = document.createElement("div");
        ocrOutput.classList.add("ocr-output");
        ocrOutput.innerText = ocrText;
        container.appendChild(ocrOutput);

        var radioGroup = document.createElement("crowd-radio-group");
        var correctRadio = document.createElement("crowd-radio-button");
        correctRadio.setAttribute("id", ["ocr", id, "correct"].join("-"));
        correctRadio.setAttribute("name", ["ocr", id, "correct"].join("-"));
        correctRadio.innerText = "Correct";
        radioGroup.appendChild(correctRadio);
        var wrongRadio = document.createElement("crowd-radio-button");
        wrongRadio.setAttribute("id", ["ocr", id, "wrong"].join("-"));
        wrongRadio.setAttribute("name", ["ocr", id, "wrong"].join("-"));
        wrongRadio.innerText = "Wrong";
        radioGroup.appendChild(wrongRadio);
        var unclearRadio = document.createElement("crowd-radio-button");
        unclearRadio.setAttribute("id", ["ocr", id, "unclear"].join("-"));
        unclearRadio.setAttribute("name", ["ocr", id, "unclear"].join("-"));
        unclearRadio.innerText = "Unclear";
        radioGroup.appendChild(unclearRadio);
        container.appendChild(radioGroup);

        var correction = document.createElement("crowd-input");
        correction.setAttribute("name", ["ocr", id, "override"].join("-"));
        correction.setAttribute("id", ["ocr", id, "override"].join("-"));
        correction.setAttribute("placeholder", "Enter correct value...");
        correction.setAttribute("label", "Closest correction");
        correction.setAttribute("disabled", "");
        correction.style.display = "none";
        container.appendChild(correction);

        var radioObserver = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if ((mutation.type == "attributes")) {
                    if (mutation.attributeName == "checked") {
                        // This is a flag attribute so takes value of "" when set, null when unset.
                        var newChecked = typeof wrongRadio.getAttribute("checked") == "string";
                        if (newChecked) {
                            correction.setAttribute("required", true);
                            correction.removeAttribute("disabled");
                            correction.style.removeProperty("display");
                        } else {
                            correction.removeAttribute("required");
                            correction.setAttribute("disabled", "");
                            correction.style.display = "none";
                        }
                    }
                }
            });
        });
        radioObserver.observe(wrongRadio, { attributes: true, });

        return container;
    }

</script>
